#include <stdlib.h>
#include <dos.h>
#include <stdio.h>
#include <mem.h>
#include "vmcosfs.h"


char *MsgErro[NUMERROS]={
	"Success",
	"Access forbidden",
	"Memory Allocation error",
	"Invalid File Handle",
	"Input/Output Error",
	"File already exists",
	"Internal Error",
	"Invalid disk drive",
	"Too many open files",
	"File not found",
	"Invalid File Name"
};

#define CurProcess 1

TDRIVE Drive[MAXDRIVES];
TFCB **BlocoControlo;
TDIRCB *BlocoDirectories;

BOOTRECORD *BootRecord;
WORD ERRO;

void GetDate(TDATA far *data)
{
	struct dosdate_t d;
	_dos_getdate(&d);

	data->ano=d.year;
	data->mes=d.month;
	data->dia=d.day;
}

void GetHora(THORA *hora)
{
	struct dostime_t t;
	_dos_gettime(&t);
	hora->hora=t.hour;
	hora->minutos=t.minute;
	hora->segundos=t.second;
	hora->centesimos=t.hsecond;
}


char *GetMsgErro(unsigned int erro)    //user
{
	if(erro<NUMERROS)
		return MsgErro[erro];
	else
		return MsgErro[EFAULT];
}

void ApagaErro()
{
	ERRO=0;
}

BYTE Montada(BYTE drive)
{
	if(drive>=MAXDRIVES)
	{
		ERRO=EINVDRV;
		return 0;
	}
	return Drive[drive].Montada;
}

void Eliminar(BYTE drive,BYTE *nome)
{
	WORD entrada;
	BYTE aberto;
	ERRO=FALSE;
	if((Drive[drive].Montada==FALSE)||(drive>=MAXDRIVES))
	{
		ERRO=EINVDRV;
		return;
	}
	if(Strlen(nome)==0)
	{
		ERRO=EINVFILE;
		return;
	}
	entrada=ProcurarEntrada(nome,drive);
	if(entrada>Drive[drive].NEntradas)
	{
		ERRO=ENOFILE;
		return;
	}
	if(Drive[drive].Entrada[entrada].Attr==So_leitura)
	{
		ERRO=EACCES;
		return;
	}
	aberto=VerificarAberto(&(Drive[drive].Entrada[entrada]));
	if(aberto)
	{
		ERRO=EACCES;
		return;
	}
	LibertaClusters(drive,Drive[drive].Entrada[entrada].FCluster);
	SetNomeEntrada(Drive[drive].Entrada[entrada].Nome,"");
}


BYTE Fim_Ficheiro(WORD bloco)
{
	ERRO=FALSE;
	if((FP_SEG(BlocoControlo[bloco])==0)||(bloco>=FILES))
	{
		ERRO=EBADF;
		return 1;
	}
	if(BlocoControlo[bloco]->Fpos>=BlocoControlo[bloco]->Tamanho)
		return 1;
	else
		return 0;
}

DWORD Ficheiro_Pos(WORD bloco)
{
	ERRO=FALSE;
	if((FP_SEG(BlocoControlo[bloco])==0)||(bloco>=FILES))
	{
		ERRO=EBADF;
		return 0L;
	}
	return BlocoControlo[bloco]->Fpos;
}

DWORD Ficheiro_Size(WORD bloco)
{
	ERRO=FALSE;
	if((FP_SEG(BlocoControlo[bloco])==0)||(bloco>=FILES))
	{
		ERRO=EBADF;
		return 0L;
	}
	return BlocoControlo[bloco]->Tamanho;
}


void Renomear(BYTE drive,BYTE *nome,BYTE *novo_nome)
{
	WORD entrada,entrada2;
	WORD len;
	ERRO=FALSE;
	if((Drive[drive].Montada==FALSE)||(drive>=MAXDRIVES))
	{
		ERRO=EINVDRV;
		return;
	}
	if(Strlen(nome)==0)
	{
		ERRO=EINVFILE;
		return;
	}
	entrada=ProcurarEntrada(nome,drive);
	if(entrada>Drive[drive].NEntradas)
	{
		ERRO=ENOFILE;
		return;
	}
	len=Strlen(novo_nome);
	if((len<1)||(len>12))
	{
		ERRO=EINVFILE;
		return;
	}
	entrada2=ProcurarEntrada(novo_nome,drive);
	if((entrada2<Drive[drive].NEntradas)&&(entrada2!=entrada))
	{
		ERRO=EEXIST;
		return;
	}
	if(Drive[drive].Entrada[entrada].Attr==So_leitura)
	{
		ERRO=EACCES;
		return;
	}
	SetNomeEntrada(Drive[drive].Entrada[entrada].Nome,novo_nome);
}

void Chmod(BYTE drive,BYTE *nome,BYTE attr)
{
	WORD entrada;
	ERRO=FALSE;
	if((Drive[drive].Montada==FALSE)||(drive>=MAXDRIVES))
	{
		ERRO=EINVDRV;
		return;
	}
	if(Strlen(nome)==0)
	{
		ERRO=EINVFILE;
		return;
	}
	entrada=ProcurarEntrada(nome,drive);
	if(entrada>Drive[drive].NEntradas)
	{
		ERRO=ENOFILE;
		return;
	}
	Drive[drive].Entrada[entrada].Attr=attr;
}

BYTE GetAttr(BYTE drive,BYTE *nome)
{
	WORD entrada;
	ERRO=FALSE;
	if((Drive[drive].Montada==FALSE)||(drive>=MAXDRIVES))
	{
		ERRO=EINVDRV;
		return 0xFF;
	}
	if(Strlen(nome)==0)
	{
		ERRO=EINVFILE;
		return 0xFF;
	}
	entrada=ProcurarEntrada(nome,drive);
	if(entrada>Drive[drive].NEntradas)
	{
		ERRO=ENOFILE;
		return 0xFF;
	}
	return Drive[drive].Entrada[entrada].Attr;
}

WORD GetEntrada(BYTE drive,BYTE first)
{
	WORD cont;
	ERRO=FALSE;
	if((Drive[drive].Montada==FALSE)||(drive>=MAXDRIVES))
	{
		ERRO=EINVDRV;
		return 0xFFFF;
	}
	if(first)
		Drive[drive]._UE=0;
	if(Drive[drive]._UE>=Drive[drive].NEntradas)
		Drive[drive]._UE=0;
	for(cont=Drive[drive]._UE;cont<Drive[drive].NEntradas;cont++)
	{
		BYTE fn = Drive[drive].Entrada[cont].Nome[0];
		if(fn!=0 && fn!=0xe5)
		{
			Drive[drive]._UE=cont+1;
			return cont;
		}
	}
	Drive[drive]._UE=cont;
	return 0xFFFF;
}

void CriarFicheiro(BYTE drive,BYTE *nome,BYTE attr)
{
	WORD entrada;
	ERRO=FALSE;
	if((Drive[drive].Montada==FALSE)||(drive>=MAXDRIVES))
	{
		ERRO=EINVDRV;
		return;
	}
	if(Strlen(nome)==0)
	{
		ERRO=EINVFILE;
		return;
	}
	entrada=ProcurarEntrada(nome,drive);
	if(entrada<Drive[drive].NEntradas)
	{
		if(Drive[drive].Entrada[entrada].Attr&So_leitura)
		{
			ERRO=EACCES;
			return;
		}
		LibertaClusters(drive,Drive[drive].Entrada[entrada].FCluster);
	}
	else
	{
		entrada=ProcurarEntrada("",drive);
		if(entrada>=Drive[drive].NEntradas)
		{
			ERRO=EFAULT;
			return;
		}
		SetNomeEntrada(Drive[drive].Entrada[entrada].Nome,nome);
	}
	Drive[drive].Entrada[entrada].FCluster=0;
	Drive[drive].Entrada[entrada].Tamanho=0;
	Drive[drive].Entrada[entrada].Attr=attr;
	Drive[drive].Entrada[entrada].Data=Ler_Packed_Data();
	Drive[drive].Entrada[entrada].Hora=Ler_Packed_Hora();
}

void LibertaClusters(BYTE drive,WORD cluster)
{
	WORD pcluster;
	if((Drive[drive].Montada==FALSE)||(drive>=MAXDRIVES))
		return;
	if(cluster>Drive[drive].NClusters)
		return;
	while((cluster>0)&&(cluster<__EOF))
	{
		pcluster=cluster;
		cluster=GetFat(drive,cluster);
		SetFat(drive,pcluster,0);
	}
}

WORD Ler_Packed_Data()
{
	TDATA data;
	WORD pdata;
	GetDate(&data);
	pdata=(data.dia<<11);
	pdata=(WORD)(pdata+(data.mes<<7));
	pdata=(WORD)(pdata+(data.ano-1980));
	return pdata;
}

TDATA UnPacked_Data(WORD pdata)
{       TDATA data;
	data.dia=(pdata>>11)&0x1F;
	data.mes=(pdata>>7)&0x0F;
	data.ano=(pdata&0x7F)+1980;
	return data;
}

WORD Ler_Packed_Hora()
{
	THORA hora;
	WORD phora;
	GetHora(&hora);
	phora=hora.hora<<11;
	phora=phora+(hora.minutos<<5);
	phora=phora+(hora.segundos>>1);
	return phora;
}

THORA UnPacked_Hora(WORD phora)
{
	THORA hora;
	hora.hora=(phora>>11)&0x1F;
	hora.minutos=(phora>>5)&0x3F;
	hora.segundos=(phora&0x1F)*2;
	hora.centesimos=0;
	return hora;
}

WORD INITFS()
{
	BYTE contador;
	ERRO=FALSE;
	for (contador=0;contador<MAXDRIVES;contador++)
			Drive[contador].Montada=FALSE;
	BootRecord=(BOOTRECORD *)AlocaMemoria(sizeof(BOOTRECORD));
	if (BootRecord==NULL)
	{
		ERRO=EMEM;
		return 0;
	}
	BlocoControlo=(TFCB **)AlocaMemoria(sizeof(TFCB *)*FILES);

	if(FP_SEG(BlocoControlo)==0)
	{
		ERRO=EMEM;
		return 0;
	}

	BlocoDirectories=(TDIRCB *)AlocaMemoria(sizeof(TDIRCB)*DIRS);
	if(FP_SEG(BlocoDirectories)==0)
	{
		ERRO=EMEM;
		return 0;
	}

	for(contador=0;contador<FILES;contador++)
		BlocoControlo[contador]=NULL;

	for(contador=0;contador<DIRS;contador++)
		BlocoDirectories[contador].handle=DCB_FREE;

	return 1;
}

void CLOSEFS()
{
	BYTE cont;
	for(cont=0;cont<MAXDRIVES;cont++)
		if(Drive[cont].Montada)
			DesMontarDrive(cont);
	LibertaMemoria(BootRecord);
	LibertaMemoria(BlocoControlo);
	LibertaMemoria(BlocoDirectories);
}

WORD MontarDrive(BYTE drive)
{
	WORD dirsect;
	WORD _fatsize,_dirsize;
	BYTE *bootid;
	BYTE *endereco;
	WORD sector;
	WORD cont;
	ERRO=FALSE;
	if(!(drive<MAXDRIVES))
	{
		ERRO=EINVDRV;
		return 0;
	}
	if(Drive[drive].Montada)
	{
		ERRO=EINVDRV;
		return 0;
	}

	/*TODO ler bootrecord*/
	if(!(LerSectorFisico(drive,0,0,1,(char far *)BootRecord)))
	{
		ERRO=EINOUT;
		return 0;
	}

	bootid=BootRecord->SystemId;
	if(!memcmp(bootid,"FAT12   ",8))
	{
		Drive[drive].Type=FAT12;
	}
	else
	{
		ERRO=EINVDRV;
		return 0;
	}
	Drive[drive].TamSector=BootRecord->Bps;
	Drive[drive].SectorCluster=BootRecord->Spc;
	Drive[drive].SectorPista=BootRecord->Spp;
	Drive[drive].Heads=BootRecord->Hn;
	Drive[drive].FATSector=BootRecord->Rs; //+BootRecord->Ssn;

	Drive[drive].DirSector=Drive[drive].FATSector+BootRecord->Spf*2;

	dirsect=((BootRecord->Rde)*32)/Drive[drive].TamSector;

	if(((BootRecord->Rde)*32)%Drive[drive].TamSector) dirsect++;
	Drive[drive].DadosSector=Drive[drive].DirSector+dirsect;
	Drive[drive].NEntradas=BootRecord->Rde;
	Drive[drive].NClusters=(BootRecord->Lsn-Drive[drive].DadosSector)/Drive[drive].SectorCluster;
	Drive[drive].NSectors=BootRecord->Lsn;

	_fatsize=(BootRecord->Spf)*Drive[drive].TamSector;

	_dirsize=dirsect*Drive[drive].TamSector;
	Drive[drive].FAT=(WORD *)AlocaMemoria(_fatsize);
	Drive[drive].Entrada=(TDIR *)AlocaMemoria(_dirsize+(_dirsize%512?512:0));
	printf("%p %p\n", Drive[drive].FAT, Drive[drive].Entrada);
	Drive[drive]._UCA=0;
	Drive[drive]._UE=0;
	Drive[drive].Montada=TRUE;
	if((!Drive[drive].FAT)||(!Drive[drive].Entrada))
	{
		/*TODO: free allocated mem*/
		ERRO=EMEM;
		return 0;
	}
	endereco=(BYTE *)Drive[drive].FAT;
	sector=Drive[drive].FATSector;
	for(cont=0;cont<_fatsize;cont++)
	{
		if(!(LerSector(drive,sector,endereco)))
		{
			Drive[drive].Montada=FALSE;
			ERRO=EINOUT;
			return 0;
		}
		sector++;
		cont+=Drive[drive].TamSector;
		endereco+=Drive[drive].TamSector;
	}
	endereco=(BYTE *)Drive[drive].Entrada;
	sector=Drive[drive].DirSector;
	printf("Dir Sector %d %d %d\n", sector, dirsect, _dirsize);
	for(cont=0;cont<_dirsize;cont++)
	{
		if(!(LerSector(drive,sector,endereco)))
		{
			Drive[drive].Montada=FALSE;
			ERRO=EINOUT;
			return 0;
		}
		sector++;
		cont+=Drive[drive].TamSector;
		endereco+=Drive[drive].TamSector;
	}
	Drive[drive]._fatsize=_fatsize;
	Drive[drive]._dirsize=_dirsize;
	return 1;
}

WORD DesMontarDrive(BYTE drive)
{
	if(!(drive<MAXDRIVES))
	{
		ERRO=EINVDRV;
		return 0;
	}
	if(Drive[drive].Montada==FALSE)
	{
		ERRO=EINVDRV;
		return 0;
	}
	FecharFicheirosDrive(drive);
	SyncDrive(drive);
	Drive[drive].Montada=FALSE;
	LibertaMemoria(Drive[drive].FAT);
	LibertaMemoria(Drive[drive].Entrada);
	return 0;
}

BYTE LerSector(BYTE drive,WORD sector,void *buffer)
{
	int head,track,sect;
	if((Drive[drive].Montada==FALSE)||(drive>=MAXDRIVES))
		return 0;
	if(sector>=Drive[drive].NSectors) return 0;
	sect=sector%Drive[drive].SectorPista+1;
	head=(sector/Drive[drive].SectorPista)%Drive[drive].Heads;
	track=(sector/Drive[drive].SectorPista)/Drive[drive].Heads;
	return (LerSectorFisico(drive,head,track,sect,buffer));
}

BYTE EscreverSector(BYTE drive,WORD sector,void *buffer)
{
	int head,track,sect;
	if((Drive[drive].Montada==FALSE)||(drive>=MAXDRIVES))
		return 0;
	if(sector>=Drive[drive].NSectors) return 0;
	sect=sector%Drive[drive].SectorPista+1;
	head=(sector/Drive[drive].SectorPista)%Drive[drive].Heads;
	track=(sector/Drive[drive].SectorPista)/Drive[drive].Heads;
	return (EscreverSectorFisico(drive,head,track,sect,buffer));
}

WORD getfat12(BYTE *map, WORD i)
{
	WORD j=(i*3)>>1;
	if(i&1) {
		return (map[j]>>4) | (map[j+1]<<4);
	}
	return map[j]&0xFF | ((map[j+1]&0x0F)<<8);
}

void setfat12(BYTE *map, WORD i, WORD v)
{
 WORD j=(i*3)>>1;
 if(i&1){
  map[j]=(map[j]&0x0f) | ((v&0xf)<<4);
  map[j+1]=v>>4;
  return;
 }
 map[j]=v&0xFF;
 map[j+1]=(map[j+1]&0xf0) | (v>>8)&0xf;
}


WORD GetFat(BYTE drive,WORD ParentCluster)
{
	WORD index;
	WORD n;
	if((Drive[drive].Montada==FALSE)||(drive>=MAXDRIVES))
		return 0xFFFF;
	if((ParentCluster<2)||(ParentCluster>Drive[drive].NClusters))
	{
		return 0xFFFF;
	}
	index=ParentCluster;

	switch(Drive[drive].Type)
	{
		case FAT12:
			n=getfat12((BYTE *)Drive[drive].FAT, index);
			if (n>=0xFF0) {
				n|=0xF000;
			}
			return n;
		default:
			return Drive[drive].FAT[index];
	}
}

void SetFat(BYTE drive,WORD ParentCluster,WORD Cluster)
{
	WORD index;
	if((Drive[drive].Montada==FALSE)||(drive>=MAXDRIVES))
	{
		ERRO=EINVDRV;
		return ;
	}
	if((ParentCluster<1)||(ParentCluster>Drive[drive].NClusters))
	{
		ERRO=EFAULT;
		return ;
	}
	index=ParentCluster;

	switch(Drive[drive].Type)
	{
		case FAT12:
			setfat12((BYTE *)Drive[drive].FAT, index, Cluster);
			break;
		default:
		Drive[drive].FAT[index]=Cluster;
	}
}

WORD SyncDrive(BYTE drive)
{
	BYTE *endereco;
	WORD sector;
	WORD cont;
	ERRO=FALSE;
	if(!(drive<MAXDRIVES))
	{
		ERRO=EINVDRV;
		return 0;
	}
	if(!Drive[drive].Montada)
	{
		ERRO=EINVDRV;
		return 0;
	}

/*save fat*/
	endereco=(BYTE *)Drive[drive].FAT;
	sector=Drive[drive].FATSector;
	for(cont=0;cont<Drive[drive]._fatsize;cont++)
	{
		if(!(EscreverSector(drive,sector,endereco)))
		{
			ERRO=EINOUT;
			return 0;
		}
		sector++;
		cont+=Drive[drive].TamSector;
		endereco+=Drive[drive].TamSector;
	}
/*Save fat copy*/
	endereco=(BYTE *)Drive[drive].FAT;
	sector=Drive[drive].FATSector+BootRecord->Spf;
	for(cont=0;cont<Drive[drive]._fatsize;cont++)
	{
		if(!(EscreverSector(drive,sector,endereco)))
		{
			ERRO=EINOUT;
			return 0;
		}
		sector++;
		cont+=Drive[drive].TamSector;
		endereco+=Drive[drive].TamSector;
	}

/*root dir*/
	endereco=(BYTE *)Drive[drive].Entrada;
	sector=Drive[drive].DirSector;
	for(cont=0;cont<Drive[drive]._dirsize;cont++)
	{
		if(!(EscreverSector(drive,sector,endereco)))
		{
			ERRO=EINOUT;
			return 0;
		}
		sector++;
		cont+=Drive[drive].TamSector;
		endereco+=Drive[drive].TamSector;
	}
	return 0;
}

WORD AlocaCluster(BYTE drive)
{
	WORD cont;
	if((Drive[drive].Montada==FALSE)||(drive>=MAXDRIVES))
	{
		ERRO=EINVDRV;
		return 0;
	}
	if(Drive[drive]._UCA>=Drive[drive].NClusters)
		Drive[drive]._UCA=0;
	for(cont=Drive[drive]._UCA+1;cont<=Drive[drive].NClusters;cont++)
	{
		if (GetFat(drive,cont)==0)
		{
			SetFat(drive,cont,__EOF);
			Drive[drive]._UCA=cont;
			return cont;
		}
	}
	for(cont=1;cont<=Drive[drive]._UCA;cont++)
	{
		if (GetFat(drive,cont)==0)
		{
			SetFat(drive,cont,__EOF);
			Drive[drive]._UCA=cont;
			return cont;
		}
	}
	return 0;
}

WORD ProcurarEntrada(BYTE *nome,BYTE drive)
{
	WORD cont;
	if((Drive[drive].Montada==FALSE)||(drive>=MAXDRIVES))
	{
		ERRO=EINVDRV;
		return 0xFFFF;
	}
	for(cont=0;cont<Drive[drive].NEntradas;cont++)
	{
		if(NomeFicheiroCmp(Drive[drive].Entrada[cont].Nome,nome))
			return cont;
	}
	return 0xFFFF;
}

BYTE NomeFicheiroCmp(BYTE *fnome,BYTE *nome)
{
	BYTE nome2[20];
	GetNomeEntrada(fnome,nome2);
	if(Strcmp(nome,nome2))
		return 0;
	else
		return 1;
}

void SetNomeEntrada(BYTE *fnome,BYTE *nome)
{
	WORD cont;
	WORD len;
	len=Strlen(nome);
	if(len>11)
		return;
	for (cont=0;cont<len;cont++)
	{
		fnome[cont]=nome[cont];
	}
	if(cont<11)
		fnome[cont]=0;
}

void GetNomeEntrada(BYTE *fnome,BYTE *nome)
{
	WORD cont;
	BYTE ef=0;
	for (cont=0;cont<8;cont++)
	{
		if(fnome[cont]=='\0' || fnome[cont]==' ') {
			break;
		}
		*nome++=fnome[cont];
	}
	*nome='\0';

	if(fnome[8]!='\0' && fnome[8] != ' ')
		*nome++='.';

	for (cont=8;cont<11;cont++) {
		if(fnome[cont]=='\0' || fnome[cont]==' ') {
			break;
		}
		*nome++=fnome[cont];
	}
	*nome='\0';
}

WORD GetFreeBloco()
{
	WORD cont;
	for(cont=0;cont<FILES;cont++)
	{
		if(BlocoControlo[cont]==NULL)
			return cont;
	}
	return 0xFFFF;
}

WORD AbrirFicheiro(BYTE drive,BYTE *nome,BYTE modo)
{
	WORD entrada;
	WORD bloco;
	TFCB *enderecobloco;
	BYTE *enderecobuffer;
	WORD buffersize;
	BYTE aberto=FALSE;
	ERRO=FALSE;
	if(Strlen(nome)==0)
	{
		ERRO=EINVFILE;
		return 0xFFFF;
	}
	if((Drive[drive].Montada==FALSE)||(drive>=MAXDRIVES))
	{
		ERRO=EINVDRV;
		return 0xFFFF;
	}
	entrada=ProcurarEntrada(nome,drive);
	if(entrada<Drive[drive].NEntradas)
		aberto=VerificarAberto(&(Drive[drive].Entrada[entrada]));
	if(((modo&CRIAR_F)||(modo&ESCREVER))&&(aberto))
	{
		ERRO=EACCES;
		return 0xFFFF;
	}
	if(modo&CRIAR_F)
	{
		CriarFicheiro(drive,nome,Sem_atributos);
		if(ERRO)
			return 0xFFFF;
	}
	entrada=ProcurarEntrada(nome,drive);
	if(entrada>=Drive[drive].NEntradas)
	{
		ERRO=ENOFILE;
		return 0xFFFF;
	}
	if((modo&ESCREVER)&&(Drive[drive].Entrada[entrada].Attr&So_leitura))
	{
		ERRO=EACCES;
		return 0xFFFF;
	}
	bloco=GetFreeBloco();
	if(bloco>=FILES)
	{
		ERRO=EMFILE;
		return 0xFFFF;
	}
	enderecobloco=(TFCB *)AlocaMemoria(sizeof(TFCB));
	if(FP_SEG(enderecobloco)==0)
	{
		ERRO=EMEM;
		return 0xFFFF;
	}
	buffersize=Drive[drive].TamSector*Drive[drive].SectorCluster;
	enderecobuffer=(BYTE *)AlocaMemoria(buffersize);
	if(FP_SEG(enderecobuffer)==0)
	{
		LibertaMemoria(enderecobloco);
		ERRO=EMEM;
		return 0xFFFF;
	}
	BlocoControlo[bloco]=enderecobloco;
	BlocoControlo[bloco]->Entrada=&(Drive[drive].Entrada[entrada]);
	BlocoControlo[bloco]->Tamanho=BlocoControlo[bloco]->Entrada->Tamanho;
	BlocoControlo[bloco]->Modo=modo;
	BlocoControlo[bloco]->Fpos=0;
	BlocoControlo[bloco]->Drive=drive;
	BlocoControlo[bloco]->Buffer=enderecobuffer;
	BlocoControlo[bloco]->FCluster=BlocoControlo[bloco]->Entrada->FCluster;
	BlocoControlo[bloco]->Cluster=0;
	BlocoControlo[bloco]->Procid=CurProcess;

	if(BlocoControlo[bloco]->Entrada->Attr&0x10) {
		if(BlocoControlo[bloco]->Tamanho==0 && BlocoControlo[bloco]->FCluster) {
			WORD cluster = BlocoControlo[bloco]->FCluster;
			while(cluster>1 && cluster < 0xfff0) {
				BlocoControlo[bloco]->Tamanho+=buffersize; //clustersize
				cluster = GetFat(drive, cluster);
			}
		}
	}
	return bloco;
}

BYTE VerificarAberto(TDIR *entrada)
{
	WORD cont;
	for(cont=0;cont<FILES;cont++)
	{
		if(BlocoControlo[cont])
		{
			if(BlocoControlo[cont]->Entrada==entrada)
				 return TRUE;
		}
	}
	return FALSE;
}

void FecharFicheiro(WORD bloco)
{
	ERRO=FALSE;
	if((FP_SEG(BlocoControlo[bloco])==0)||(bloco>=FILES))
	{
		ERRO=EBADF;
		return;
	}
	if(BlocoControlo[bloco]->Modo&ESCREVER)
	{
		FlushFicheiro(bloco);
		BlocoControlo[bloco]->Entrada->Tamanho=BlocoControlo[bloco]->Tamanho;
		BlocoControlo[bloco]->Entrada->FCluster=BlocoControlo[bloco]->FCluster;
		BlocoControlo[bloco]->Entrada->Data=Ler_Packed_Data();
		BlocoControlo[bloco]->Entrada->Hora=Ler_Packed_Hora();
	}
	LibertaMemoria(BlocoControlo[bloco]->Buffer);
	LibertaMemoria(BlocoControlo[bloco]);
	BlocoControlo[bloco]=NULL;
}

void FlushFicheiro(WORD bloco)
{
	WORD deslocamento;
	WORD tamcluster;
	BYTE drive;
	if((BlocoControlo[bloco]==NULL)||(bloco>=FILES))
	{
		ERRO=EBADF;
		return;
	}
	drive=BlocoControlo[bloco]->Drive;
	tamcluster=Drive[drive].TamSector*Drive[drive].SectorCluster;
	deslocamento=BlocoControlo[bloco]->Fpos%tamcluster;
	if(deslocamento)
	{
		EscreverCluster(drive,BlocoControlo[bloco]->Cluster,BlocoControlo[bloco]->Buffer);
		if(ERRO)
		{
			return;
		}
	}
}

void FecharFicheirosDrive(BYTE drive)
{
	WORD cont;
	if((Drive[drive].Montada==FALSE)||(drive>=MAXDRIVES))
	{
		ERRO=EINVDRV;
		return;
	}
	for(cont=0;cont<FILES;cont++)
	{
		if(BlocoControlo[cont]==NULL)
			continue;
		if(BlocoControlo[cont]->Drive==drive)
			FecharFicheiro(cont);
	}
}

void FecharFicheirosProcesso(WORD procid)
{
	WORD cont;
	for(cont=0;cont<FILES;cont++)
	{
		if(BlocoControlo[cont]->Procid==procid)
			FecharFicheiro(cont);
	}
}

WORD EscreverCaracter(WORD bloco,BYTE caracter)
{
	WORD deslocamento;
	WORD tamcluster;
	WORD cluster_anterior;
	BYTE drive;
	ERRO=FALSE;
	if((BlocoControlo[bloco]==NULL)||(bloco>=FILES))
	{
		ERRO=EBADF;
		return 0;
	}
	if(!(BlocoControlo[bloco]->Modo&ESCREVER))
	{
		ERRO=EACCES;
		return 0;
	}
	if(!(BlocoControlo[bloco]->Fpos<BlocoControlo[bloco]->Tamanho))
	{
		if(!(BlocoControlo[bloco]->Modo&EXPANDIR))
		{
			return __EOF;
		}
	}
	drive=BlocoControlo[bloco]->Drive;
	tamcluster=Drive[drive].TamSector*Drive[drive].SectorCluster;
	deslocamento=BlocoControlo[bloco]->Fpos%tamcluster;
	if(deslocamento==0)
	{
		cluster_anterior=BlocoControlo[bloco]->Cluster;
		if(BlocoControlo[bloco]->FCluster==0)
		{
			BlocoControlo[bloco]->FCluster=AlocaCluster(drive);
			BlocoControlo[bloco]->Cluster=BlocoControlo[bloco]->FCluster;
		}
		else
		{
			if(BlocoControlo[bloco]->Cluster==0)
				  BlocoControlo[bloco]->Cluster=BlocoControlo[bloco]->FCluster;
			else
				  BlocoControlo[bloco]->Cluster=GetFat(drive,BlocoControlo[bloco]->Cluster);
			if(BlocoControlo[bloco]->Cluster==0)
			{
				BlocoControlo[bloco]->Cluster=cluster_anterior;
				ERRO=EFAULT;
				return 0;
			}
			if(BlocoControlo[bloco]->Cluster>=__EOF)
			{
				BlocoControlo[bloco]->Cluster=AlocaCluster(drive);
				SetFat(drive,cluster_anterior,BlocoControlo[bloco]->Cluster);
			}
			else
			{
				LerCluster(drive,BlocoControlo[bloco]->Cluster,BlocoControlo[bloco]->Buffer);
				if(ERRO)
				{
					BlocoControlo[bloco]->Cluster=cluster_anterior;
					return 0;
				}
			}
		}
		if(BlocoControlo[bloco]->Cluster==0)
		{
			ERRO=EFAULT;
			return 0;
		}
	}
	BlocoControlo[bloco]->Buffer[deslocamento]=caracter;
	BlocoControlo[bloco]->Fpos++;
	deslocamento=BlocoControlo[bloco]->Fpos%tamcluster;
	if(deslocamento==0)
	{
		EscreverCluster(drive,BlocoControlo[bloco]->Cluster,BlocoControlo[bloco]->Buffer);
		if(ERRO)
		{
			BlocoControlo[bloco]->Fpos--;
			return 0;
		}
	}
	if(BlocoControlo[bloco]->Fpos>BlocoControlo[bloco]->Tamanho)
		BlocoControlo[bloco]->Tamanho=BlocoControlo[bloco]->Fpos;
	return 0;

}


WORD EscreverFicheiro(WORD bloco, char far *ptr, WORD len)
{
	WORD deslocamento;
	WORD tamcluster;
	WORD cluster_anterior;
	BYTE drive;
	WORD count=0;
	WORD ksize=0;
	ERRO=FALSE;
	if((BlocoControlo[bloco]==NULL)||(bloco>=FILES))
	{
		ERRO=EBADF;
		return 0;
	}
	if(!(BlocoControlo[bloco]->Modo&ESCREVER))
	{
		ERRO=EACCES;
		return 0;
	}
	if(BlocoControlo[bloco]->Fpos+len>BlocoControlo[bloco]->Tamanho)
	{
		if(!(BlocoControlo[bloco]->Modo&EXPANDIR))
		{
		  /*TODO reduce length*/
			return 0;
		}
	}
	drive=BlocoControlo[bloco]->Drive;
	tamcluster=Drive[drive].TamSector*Drive[drive].SectorCluster;
	while(len) {
	  deslocamento=BlocoControlo[bloco]->Fpos%tamcluster;
	  if(deslocamento==0)
	  {
		  cluster_anterior=BlocoControlo[bloco]->Cluster;
		  if(BlocoControlo[bloco]->FCluster==0)
		  {
			  BlocoControlo[bloco]->FCluster=AlocaCluster(drive);
			  BlocoControlo[bloco]->Cluster=BlocoControlo[bloco]->FCluster;
		  }
		  else
		  {
			  if(BlocoControlo[bloco]->Cluster==0)
				    BlocoControlo[bloco]->Cluster=BlocoControlo[bloco]->FCluster;
			  else
				    BlocoControlo[bloco]->Cluster=GetFat(drive,BlocoControlo[bloco]->Cluster);
			  if(BlocoControlo[bloco]->Cluster==0)
			  {
				  BlocoControlo[bloco]->Cluster=cluster_anterior;
				  ERRO=EFAULT;
				  return count;
			  }
			  if(BlocoControlo[bloco]->Cluster>=__EOF)
			  {
				  BlocoControlo[bloco]->Cluster=AlocaCluster(drive);
				  SetFat(drive,cluster_anterior,BlocoControlo[bloco]->Cluster);
			  }
			  else
			  {
				  LerCluster(drive,BlocoControlo[bloco]->Cluster,BlocoControlo[bloco]->Buffer);
				  if(ERRO)
				  {
					  BlocoControlo[bloco]->Cluster=cluster_anterior;
					  return count;
				  }
			  }
		  }
		  if(BlocoControlo[bloco]->Cluster==0)
		  {
			  ERRO=EFAULT;
			  return count;
		  }
	  }
	  ksize = tamcluster-deslocamento;

	  if(ksize==0)
	    break;

	  if(ksize>len)
	    ksize=len;

	  _fmemcpy(BlocoControlo[bloco]->Buffer+deslocamento,ptr+count,ksize);

	  BlocoControlo[bloco]->Fpos+=ksize;
	  count+=ksize;
	  len-=ksize;

	  deslocamento=BlocoControlo[bloco]->Fpos%tamcluster;
	  if(deslocamento==0)
	  {
		  EscreverCluster(drive,BlocoControlo[bloco]->Cluster,BlocoControlo[bloco]->Buffer);
		  if(ERRO)
		  {
			  BlocoControlo[bloco]->Fpos-=ksize;
			  count-=ksize;
			  return count;
		  }
	  }
	  if(BlocoControlo[bloco]->Fpos>BlocoControlo[bloco]->Tamanho)
		  BlocoControlo[bloco]->Tamanho=BlocoControlo[bloco]->Fpos;
	}
	return count;

}


void EscreverCluster(BYTE drive,WORD cluster,BYTE *buffer)
{
	WORD cont;
	WORD sector;
	ERRO=FALSE;
	if((Drive[drive].Montada==FALSE)||(drive>=MAXDRIVES))
	{
		ERRO=EINVDRV;
		return;
	}
	if((cluster<1)||(cluster>Drive[drive].NClusters))
	{
		ERRO=EFAULT;
		return;
	}
	sector=Drive[drive].DadosSector+(cluster-2)*Drive[drive].SectorCluster;
	for(cont=0;cont<Drive[drive].SectorCluster;cont++)
	{
	  if(!(EscreverSector(drive,sector,buffer)))
		{
			ERRO=EINOUT;
			return ;
		}
	  buffer=buffer+Drive[drive].TamSector;
	  sector++;
	}
}

void LerCluster(BYTE drive,WORD cluster,BYTE *buffer)
{
	WORD cont;
	WORD sector;
	ERRO=FALSE;
	if((Drive[drive].Montada==FALSE)||(drive>=MAXDRIVES))
	{
		ERRO=EINVDRV;
		return;
	}
	if((cluster<2)||(cluster>Drive[drive].NClusters))
	{
		ERRO=EFAULT;
		return;
	}
	sector=Drive[drive].DadosSector+(cluster-2)*Drive[drive].SectorCluster;
	for(cont=0;cont<Drive[drive].SectorCluster;cont++)
	{
	  if(!(LerSector(drive,sector,buffer)))
		{
			ERRO=EINOUT;
			return ;
		}
	  buffer=buffer+Drive[drive].TamSector;
	  sector++;
	}
}

WORD LerCaracter(WORD bloco)
{
	WORD deslocamento;
	WORD cluster_anterior;
	WORD tamcluster;
	BYTE caracter;
	BYTE drive;
	ERRO=FALSE;
	if((FP_SEG(BlocoControlo[bloco])==0)||(bloco>=FILES))
	{
		ERRO=EBADF;
		return 0xFFFF;
	}
	if(!(BlocoControlo[bloco]->Fpos<BlocoControlo[bloco]->Tamanho))
	{
		return __EOF;
	}
	drive=BlocoControlo[bloco]->Drive;
	tamcluster=Drive[drive].TamSector*Drive[drive].SectorCluster;
	deslocamento=BlocoControlo[bloco]->Fpos%tamcluster;
	if(deslocamento==0)
	{
		cluster_anterior=BlocoControlo[bloco]->Cluster;
		if(BlocoControlo[bloco]->Cluster==0)
			BlocoControlo[bloco]->Cluster=BlocoControlo[bloco]->FCluster;
		else
			BlocoControlo[bloco]->Cluster=GetFat(drive,BlocoControlo[bloco]->Cluster);
		if(!((BlocoControlo[bloco]->Cluster>0)&&(BlocoControlo[bloco]->Cluster<__EOF)))
		{
			BlocoControlo[bloco]->Cluster=cluster_anterior;
			ERRO=EFAULT;
			return 0xFFFF;
		}
		LerCluster(drive,BlocoControlo[bloco]->Cluster,BlocoControlo[bloco]->Buffer);
		if(ERRO)
		{
			BlocoControlo[bloco]->Cluster=cluster_anterior;
			return 0xFFFF;
		}
	}
	caracter=BlocoControlo[bloco]->Buffer[deslocamento];
	BlocoControlo[bloco]->Fpos++;
	return caracter;

}

WORD LerFicheiro(WORD bloco, char far *ptr, WORD len)
{
	WORD deslocamento;
	WORD cluster_anterior;
	WORD tamcluster;
	BYTE caracter;
	BYTE drive;
	WORD count=0;
	WORD ksize=0;
	ERRO=FALSE;
	if((FP_SEG(BlocoControlo[bloco])==0)||(bloco>=FILES))
	{
		ERRO=EBADF;
		return 0;
	}
	if(!(BlocoControlo[bloco]->Fpos<BlocoControlo[bloco]->Tamanho))
	{
		return 0;
	}
	drive=BlocoControlo[bloco]->Drive;
	tamcluster=Drive[drive].TamSector*Drive[drive].SectorCluster;
	while(len) {
	  deslocamento=BlocoControlo[bloco]->Fpos%tamcluster;
	  if(deslocamento==0)
	  {
		  cluster_anterior=BlocoControlo[bloco]->Cluster;
		  if(BlocoControlo[bloco]->Cluster==0)
			  BlocoControlo[bloco]->Cluster=BlocoControlo[bloco]->FCluster;
		  else
			  BlocoControlo[bloco]->Cluster=GetFat(drive,BlocoControlo[bloco]->Cluster);
		  if(!((BlocoControlo[bloco]->Cluster>0)&&(BlocoControlo[bloco]->Cluster<__EOF)))
		  {
			  BlocoControlo[bloco]->Cluster=cluster_anterior;
			  ERRO=EFAULT;
			  return 0;
		  }
		  LerCluster(drive,BlocoControlo[bloco]->Cluster,BlocoControlo[bloco]->Buffer);
		  if(ERRO)
		  {
			  BlocoControlo[bloco]->Cluster=cluster_anterior;
			  return 0;
		  }
		  
	  }
	  ksize = tamcluster-deslocamento;
	  if(ksize > BlocoControlo[bloco]->Tamanho-BlocoControlo[bloco]->Fpos )
	    ksize=BlocoControlo[bloco]->Tamanho-BlocoControlo[bloco]->Fpos;

	  if(ksize==0)
	    break;

	  if(ksize>len)
	    ksize=len;

	  _fmemcpy(ptr+count,BlocoControlo[bloco]->Buffer+deslocamento,ksize);

	  BlocoControlo[bloco]->Fpos+=ksize;
	  count+=ksize;
	  len-=ksize;
	  
	  if(!(BlocoControlo[bloco]->Fpos<BlocoControlo[bloco]->Tamanho))
	    break;
	}
	return count;
}


void PosicionarFicheiro(WORD bloco,long deslocamento,BYTE modo)
{
	DWORD n_pos;
	WORD n_cluster;
	WORD nciclos;
	WORD cont;
	BYTE drive;
	WORD tamcluster;
	ERRO=FALSE;
	if((BlocoControlo[bloco]==NULL)||(bloco>=FILES))
	{
		ERRO=EBADF;
		return;
	}
	switch(modo)
	{
		case SF_INICIO:
			n_pos=deslocamento;break;
		case SF_CURRENTE:
			n_pos=BlocoControlo[bloco]->Fpos+deslocamento;break;
		case SF_FIM:
			n_pos=BlocoControlo[bloco]->Tamanho+deslocamento;break;
		default:
			ERRO=EFAULT;
			return;
	}
	if(n_pos>BlocoControlo[bloco]->Tamanho)
	{
		ERRO=EFAULT;
		return;
	}
	if(n_pos==0)
	{
		BlocoControlo[bloco]->Cluster=0;
		BlocoControlo[bloco]->Fpos=0;
		return;
	}
	drive=BlocoControlo[bloco]->Drive;
	tamcluster=Drive[drive].TamSector*Drive[drive].SectorCluster;
	nciclos=(n_pos-1)/tamcluster;
	n_cluster=BlocoControlo[bloco]->FCluster;
	if(n_cluster>Drive[drive].NClusters)
	{
		ERRO=EFAULT;
		return;
	}
	for(cont=0;cont<nciclos;cont++)
	{
		n_cluster=GetFat(drive,n_cluster);
		if((n_cluster<1)||(n_cluster>Drive[drive].NClusters))
		{
			ERRO=EFAULT;
			return;
		}
	}
	if(n_pos%tamcluster)
	{
		LerCluster(drive,n_cluster,BlocoControlo[bloco]->Buffer);
		if(ERRO)
			return;
	}
	BlocoControlo[bloco]->Cluster=n_cluster;
	BlocoControlo[bloco]->Fpos=n_pos;
}

void TruncarFicheiro(WORD bloco)
{
	BYTE drive;
	ERRO=FALSE;
	if((BlocoControlo[bloco]==NULL)||(bloco>=FILES))
	{
		ERRO=EBADF;
		return;
	}
	if(!(BlocoControlo[bloco]->Modo&ESCREVER))
	{
		ERRO=EACCES;
		return;
	}
	drive=BlocoControlo[bloco]->Drive;
	BlocoControlo[bloco]->Tamanho=BlocoControlo[bloco]->Fpos;
	if(BlocoControlo[bloco]->Tamanho==0)
	{
		LibertaClusters(drive,BlocoControlo[bloco]->FCluster);
		BlocoControlo[bloco]->FCluster=0;
	}
	else
	{
		LibertaClusters(drive,GetFat(drive,BlocoControlo[bloco]->Cluster));
		SetFat(drive,BlocoControlo[bloco]->Cluster,__EOF);
	}
}

WORD FreeClusters(BYTE drive)
{
	WORD cont;
	WORD free=0;
	if(drive>=MAXDRIVES)
		return 0;
	if(Drive[drive].Montada==FALSE)
		return 0;
	for(cont=1;cont<=Drive[drive].NClusters;cont++)
	{
		if(GetFat(drive,cont)==0)
			free++;
	}
	return free;
}

DWORD FreeSpace(BYTE drive)
{
	DWORD frees;
	WORD tamcluster;
	if(drive>=MAXDRIVES)
		return 0;
	if(Drive[drive].Montada==FALSE)
		return 0;
	tamcluster=Drive[drive].TamSector*Drive[drive].SectorCluster;
	frees=(DWORD)FreeClusters(drive)*tamcluster;
	return frees;
}

DWORD DiskSpace(BYTE drive)
{
	WORD tamcluster;
	if(drive>=MAXDRIVES)
		return 0;
	if(Drive[drive].Montada==FALSE)
		return 0;
	tamcluster=Drive[drive].TamSector*Drive[drive].SectorCluster;
	return (DWORD)Drive[drive].NClusters*tamcluster;
}

BYTE LerSectorFisico(char drive,char head,char track,char sector,char far *buffer)
{
	WORD entries=0;
	BYTE OK=0;
	int segb=FP_SEG(buffer),ofsb=FP_OFF(buffer);
	char r;
	if(drive>=MAXDRIVES)
		return 0;

	while((entries<NENTRIES)&&(!OK))
	{
		asm{
			mov ah,0x2;
			mov al,0x1;
			mov ch,track;
			mov cl,sector;
			mov dh,head;
			mov dl,drive;
			mov es,segb;
			mov bx,ofsb;
			int 0x13;
			mov r,0;
			jnc done;
			mov r,1;
			}
		done:
		if(!r)
			OK=1;
		entries++;
	}
	return OK;
}

BYTE EscreverSectorFisico(char drive,char head,char track,char sector,char far *buffer)
{
	WORD entries=0;
	int segb=FP_SEG(buffer),ofsb=FP_OFF(buffer);
	char r;
	BYTE OK=0;
	if(drive>=MAXDRIVES)
		return 0;
	while((entries<NENTRIES)&&(!OK))
	{
		asm{
			mov ah,0x3;
			mov al,0x1;
			mov ch,track;
			mov cl,sector;
			mov dh,head;
			mov dl,drive;
			mov es,segb;
			mov bx,ofsb;
			int 0x13;
			mov r,0;
			jnc done;
			mov r,1;
		}
		done:
		if(!r)
			OK=1;
		entries++;
	}
	return OK;
}

BYTE DirProcura(BYTE drive,TDIR_RECORD *rec,BYTE first)
{
	WORD entrada;
	ERRO=FALSE;
	if((Drive[drive].Montada==FALSE)||(drive>=MAXDRIVES))
	{
		ERRO=EINVDRV;
		return 0;
	}
	entrada=GetEntrada(drive,first);
	if (entrada<Drive[drive].NEntradas)
	{
		GetNomeEntrada(Drive[drive].Entrada[entrada].Nome,rec->nome);
		rec->Data=UnPacked_Data(Drive[drive].Entrada[entrada].Data);
		rec->Hora=UnPacked_Hora(Drive[drive].Entrada[entrada].Hora);
		rec->Attr=Drive[drive].Entrada[entrada].Attr;
		rec->Tamanho=Drive[drive].Entrada[entrada].Tamanho;
		return 1;
	}
	else
	{
		rec->Attr=0;
		rec->Data=UnPacked_Data(0);
		rec->Hora=UnPacked_Hora(0);
		rec->Tamanho=0L;
		rec->nome[0]=0;
		return 0;
	}
}

WORD OpenDirectory(BYTE drive, BYTE *path, BYTE mode)
{
	WORD dh;
	WORD fh;

	for(dh=0;dh<DIRS;dh++) {
		if(BlocoDirectories[dh].handle==DCB_FREE) {
			goto found;
		}
	}
	return __EOF;


found:
	BlocoDirectories[dh].drive=drive;
	BlocoDirectories[dh].rec=0;

	if(!strcmp(path,"") || !strcmp(path,"/")) {
		BlocoDirectories[dh].handle=DCB_ROOT;
		return dh;
	}
	printf("Opening dir Drive %d path %s\n");
	fh=AbrirFicheiro(drive,path,mode);
	if(fh<FILES) {
		BlocoDirectories[dh].handle=fh;
		return dh;
	}
	return __EOF;
}

/*TODO CloseDir*/

WORD ReadDir(WORD dh, TDIR_RECORD *rec)
{
	WORD fh;

	rec->Attr=0;
	rec->Data=UnPacked_Data(0);
	rec->Hora=UnPacked_Hora(0);
	rec->Tamanho=0L;
	rec->nome[0]=0;

	if(dh>=DIRS)
		return 0;
	if(BlocoDirectories[dh].handle==DCB_ROOT) {
		WORD cnt=0;
		WORD entrada=BlocoDirectories[dh].rec;
		WORD drive=BlocoDirectories[dh].drive;
		for(entrada=BlocoDirectories[dh].rec;
		    entrada<Drive[drive].NEntradas;
		    entrada=++BlocoDirectories[dh].rec
		    )
		{
			BYTE flag = Drive[drive].Entrada[entrada].Nome[0];
			if(flag==0 || flag == 0xe5) {
				continue;
			}
			GetNomeEntrada(Drive[drive].Entrada[entrada].Nome,rec->nome);
			rec->Data=UnPacked_Data(Drive[drive].Entrada[entrada].Data);
			rec->Hora=UnPacked_Hora(Drive[drive].Entrada[entrada].Hora);
			rec->Attr=Drive[drive].Entrada[entrada].Attr;
			rec->Tamanho=Drive[drive].Entrada[entrada].Tamanho;

			BlocoDirectories[dh].rec++;
			return 1;
		}
		return 0;
	}

	fh=BlocoDirectories[dh].handle;


	while(!Fim_Ficheiro(fh))
	{
		TDIR buffer;
		WORD c=0;
		WORD count=LerFicheiro(fh, &buffer, sizeof(TDIR));
		if(ERRO)
			return 0;
		if (!count)
			return 0;

		BlocoDirectories[dh].rec++;

		if(buffer.Nome[0]==0 || buffer.Nome[0]==0xe5) {
			continue;
		}

		GetNomeEntrada(buffer.Nome,rec->nome);
		rec->Data=UnPacked_Data(buffer.Data);
		rec->Hora=UnPacked_Hora(buffer.Hora);
		rec->Attr=buffer.Attr;
		rec->Tamanho=buffer.Tamanho;
		return 1;
	}
	return 0;
}

/************UTIL***********/

#define escreve_erro() if(ERRO) fprintf(stderr,"%s\n",GetMsgErro(ERRO));


void MountDrive(char c)
{
	char d=-1;
	switch(c)
	{
		case 'A':
		case 'a':d=0;break;
		case 'B':
		case 'b':d=1;break;
	}

	if(d==-1)
	{
		printf("Invalid drive\n");
		return;
	}

	if(Montada(d))
	{
		printf("Drive is already mounted\n");
		return;
	}

	if(!MontarDrive(d)) {
		printf("Error...Cannot mount drive\n");
		return;
	}

	printf("Drive successful mounted\n");
}

void Ls(char *path)
{
	TDIR_RECORD d;
	WORD dh;
	int linhas,numl;
	int nfich;
	char v,i;
	char out[20];
	char drive=-1;
	char c;
	if(*path=='/') path++;
	if(path[1]=='/') {
		c=path[0];
		path+=2;
	} else {
		c='A';
	}

	switch(c)
	{
		case 'A':
		case 'a':drive=0;break;
		case 'B':
		case 'b':drive=1;break;
	}
	ApagaErro();
	if(drive>1 || drive < 0)
	{
		printf("Dispositivo Inv lido...\n\n");
		return;
	}
	MontarDrive(drive);
	if(!Montada(drive))
	{
		printf("A Drive nÆo se encontra montada...\n\n");
		return;
	}
	printf("Listagem da Drive %c:\n",'A'+drive);
	linhas=25;
	numl=0;
	nfich=0;
	v=1;
	dh=OpenDirectory(drive, path, LEITURA);
	printf("dh: %d\n", dh);
	while(ReadDir(dh, &d))
	{
		v=0;
		numl++;
		nfich++;

		if( (d.Attr&0x8) || (d.Attr&0x0F)==0x0F) {
			continue;
		}
		strncpy(out,d.nome,12);
		out[12]=0;

		printf(
			"%-12s %5s %8lu Bytes %04u-%02u-%02u %02u:%02u %s\n",
			out,
			d.Attr&0x10 ? "<DIR>": "",
			d.Tamanho,
			d.Data.ano, d.Data.mes, d.Data.dia,
			d.Hora.hora, d.Hora.minutos,
			d.Attr&So_leitura ? "READ_ONLY" : ""
		);
		if(numl>=linhas-4)
		{
			printf("Prima qualquer Tecla para Continuar ou ESC para Terminar...\n\n");
			if(getchar()==27) break;
			numl=0;
		}
	}
	printf("\nNumber of entries:   %8u\n", nfich);
	printf("Free Disk Space:     %8lu\n", FreeSpace(drive));
	printf("Total Disk Space:    %8lu\n", DiskSpace(drive));

	if(ERRO)
		fprintf(stderr,"%s\n",GetMsgErro(ERRO));
}

void copymd(char drv, char *mfile, char *dpath)
{
	char drive=0;
	WORD handle;
	WORD ch;
	WORD lines;
	FILE *fp;
	switch(drv)
	{
		case 'A':
		case 'a':drive=0;break;
		case 'B':
		case 'b':drive=1;break;
	}
	MountDrive(drv);
	ApagaErro();
	fp=fopen(dpath,"wb");
	if(!fp) {
		fprintf(stderr,"Erro a criar ficheiro de destino %s\n", dpath);
		return;
	}
	handle=AbrirFicheiro(drive,mfile,LEITURA);
	printf("Drive %d %s\n", drive, mfile);
	if((handle>=FILES)||(ERRO))
	{
		fprintf(stderr,"Erro a abrir ficheiro de origem...\n");
		escreve_erro();
		fclose(fp);
		return;
	}
	lines=0;
	while(!Fim_Ficheiro(handle))
	{
		ch=LerCaracter(handle);
		if(ERRO) break;
		fputc(ch,fp);
	}
	FecharFicheiro(handle);
	fclose(fp);
}

#define buffersize 3000
char buffer[buffersize];

void testread(char drv, char *mfile, char *dpath)
{
	char drive=0;
	WORD handle;
	WORD ch;
	WORD lines;

	FILE *fp;
	switch(drv)
	{
		case 'A':
		case 'a':drive=0;break;
		case 'B':
		case 'b':drive=1;break;
	}
	MountDrive(drv);
	ApagaErro();
	fp=fopen(dpath,"wb");
	if(!fp) {
		fprintf(stderr,"Erro a criar ficheiro de destino %s\n", dpath);
		return;
	}
	handle=AbrirFicheiro(drive,mfile,LEITURA);
	printf("Drive %d %s\n", drive, mfile);
	if((handle>=FILES)||(ERRO))
	{
		fprintf(stderr,"Erro a abrir ficheiro de origem...\n");
		escreve_erro();
		fclose(fp);
		return;
	}
	lines=0;
	while(!Fim_Ficheiro(handle))
	{
	  WORD c=0;
	  WORD count=LerFicheiro(handle, buffer, buffersize);
		//ch=LerCaracter(handle);
		if(ERRO) break;
		while(count--)
		  fputc(buffer[c++],fp);
	}
	FecharFicheiro(handle);
	fclose(fp);
}



void test_display(char drv, char *mfile)
{
	char drive=0;
	WORD handle;
	WORD ch;
	WORD lines;

	switch(drv)
	{
		case 'A':
		case 'a':drive=0;break;
		case 'B':
		case 'b':drive=1;break;
	}
	MountDrive(drv);
	ApagaErro();
	handle=AbrirFicheiro(drive,mfile,LEITURA);
	printf("Drive %d %s\n", drive, mfile);
	if((handle>=FILES)||(ERRO))
	{
		fprintf(stderr,"Erro a abrir ficheiro de origem...\n");
		escreve_erro();
		return;
	}
	printf("FCB %u\n", BlocoControlo[handle]->FCluster);
	lines=0;
	while(!Fim_Ficheiro(handle))
	{
	  WORD c=0;
	 // WORD count=LerFicheiro(handle, buffer, buffersize);
	 WORD count=0;
	  printf("%c", LerCaracter(handle));
		//ch=LerCaracter(handle);
		if(ERRO) break;
		while(count--)
		  putchar(buffer[c++]);
	}
	FecharFicheiro(handle);
}

/*
void copymm(char drv, char *mfile, char *dpath)
{
	char drive=0;
	WORD handle;
	WORD ch;
	WORD lines;
	FILE *fp;
	switch(drv)
	{
		case 'A':
		case 'a':drive=0;break;
		case 'B':
		case 'b':drive=1;break;
	}
	MountDrive(drv);
	ApagaErro();
	fp=fopen(dpath,"")
	handle=AbrirFicheiro(drive,mfile,LEITURA);
	printf("Drive %d %s\n", drive, mfile);
	if((handle>=FILES)||(ERRO))
	{
		fprintf(stderr,"Erro a abrir ficheiro de origem...\n");
		//escreve_erro();
		return;
	}
	lines=0;
	while(!Fim_Ficheiro(handle))
	{
		ch=LerCaracter(handle);
		if(ERRO) break;
		putchar(ch);
	}
	FecharFicheiro(handle);
}
*/


void testwrite(char *dpath,char drv, char *mfile)
{
	char drive=0;
	WORD handle;
	WORD ch;
	size_t count;
	FILE *fp;
	switch(drv)
	{
		case 'A':
		case 'a':drive=0;break;
		case 'B':
		case 'b':drive=1;break;
	}
	MountDrive(drv);
	ApagaErro();
	fp=fopen(dpath,"rb");
	handle=AbrirFicheiro(drive,mfile,CRIAR_F|ESCREVER|EXPANDIR);
	printf("Drive %d %s\n", drive, mfile);
	if((handle>=FILES)||(ERRO))
	{
		fprintf(stderr,"Erro a abrir ficheiro de origem...\n");
		escreve_erro();
		return;
	}
	while( (count=fread(buffer,1,3000,fp))!=0 )
	{
		//int i=0;
		//for (i=0;i<count;i++) {
		//	putchar(buffer[i]);
		//}
		//ch=fgetc(fp);
		printf("Count %u\n", count);
		EscreverFicheiro(handle,buffer,count);
		//while()
		if(ERRO) break;
	}
	FecharFicheiro(handle);
	fclose(fp);
	putchar('\n');
}


void copydm(char *dpath,char drv, char *mfile)
{
	char drive=0;
	WORD handle;
	WORD ch;
	WORD lines;
	FILE *fp;
	switch(drv)
	{
		case 'A':
		case 'a':drive=0;break;
		case 'B':
		case 'b':drive=1;break;
	}
	MountDrive(drv);
	ApagaErro();
	fp=fopen(dpath,"rb");
	handle=AbrirFicheiro(drive,mfile,CRIAR_F|ESCREVER|EXPANDIR);
	printf("Drive %d %s\n", drive, mfile);
	if((handle>=FILES)||(ERRO))
	{
		fprintf(stderr,"Erro a abrir ficheiro de origem...\n");
		escreve_erro();
		return;
	}
	lines=0;
	while(!feof(fp))
	{
		ch=fgetc(fp);
		if(ch>255)
			break;
		EscreverCaracter(handle,ch);
		if(ERRO) break;
	}
	FecharFicheiro(handle);
	fclose(fp);
}


void copy(char *from, char *to)
{
	char from_drv=0;
	char to_drv=0;
	if(from[0]=='/') {
		from_drv=-1;
		if(from[2]=='/') {
			switch(from[1])
			{
				case 'a':
				case 'A':
				case 'b':
				case 'B':  from_drv=from[1];
				break;
			}
		}

	}
	if(to[0]=='/') {
		to_drv=-1;
		if(to[2]=='/') {
			switch(to[1])
			{
				case 'a':
				case 'A':
				case 'b':
				case 'B':  to_drv=to[1];
				break;
			}
		}
	}
	if(from_drv==-1 || to_drv==-1){
		fprintf(stderr, "Invalid syntax\n");
		return;
	}
	if(from_drv && to_drv) {
	      //	copymm(
	      //		from_drv,&from[3],
	      //		to_drv,  &to[3]
	      //	);
	}
	else if(from_drv) {
		copymd( from_drv,&from[3],to );
	}
	else if(to_drv) {
		copydm(from,to_drv,&to[3]);
	}
}


void test(char *from, char *to)
{
	char from_drv=0;
	char to_drv=0;
	if(from[0]=='/') {
		from_drv=-1;
		if(from[2]=='/') {
			switch(from[1])
			{
				case 'a':
				case 'A':
				case 'b':
				case 'B':  from_drv=from[1];
				break;
			}
		}

	}
	if(to[0]=='/') {
		to_drv=-1;
		if(to[2]=='/') {
			switch(to[1])
			{
				case 'a':
				case 'A':
				case 'b':
				case 'B':  to_drv=to[1];
				break;
			}
		}
	}
	if(from_drv==-1 || to_drv==-1){
		fprintf(stderr, "Invalid syntax\n");
		return;
	}
	if(from_drv && to_drv) {
	      //	copymm(
	      //		from_drv,&from[3],
	      //		to_drv,  &to[3]
	      //	);
	}
	else if(from_drv) {
		printf("Test read\n");
		testread( from_drv,&from[3],to );
	}
	else if(to_drv) {
		printf("Test Write\n");
		testwrite(from,to_drv,&to[3]);
	}
}

void testd(char *from)
{
	char from_drv=0;
	if(from[0]=='/') {
		from_drv=-1;
		if(from[2]=='/') {
			switch(from[1])
			{
				case 'a':
				case 'A':
				case 'b':
				case 'B':  from_drv=from[1];
				break;
			}
		}

	}
	if(from_drv==-1){
		fprintf(stderr, "Invalid syntax\n");
		return;
	}
	else if(from_drv) {
		printf("Test Display\n");
		test_display( from_drv,&from[3]);
	}
}


main(int argc, char **argv)
{
	if(!INITFS())
	{
		fprintf(stderr, "Cannot init mcos filesystem\n");
		return -2;
	}

	if(argc>1) {
		if(!strcmp(argv[1],"ls")) {
			char *path="/a/";

			if(argc>2) {
				path=argv[2];
			}
			Ls(path);

		}
		else if(!strcmp(argv[1],"cp")) {
			if(argc==3) {
				//copy(argv[2],".");
			}
			else if(argc==4) {
				copy(argv[2],argv[3]);
			}
			else {
				fprintf(stderr, "missing arguments...\n");
			}
		}
		else if(!strcmp(argv[1],"test")) {
			if(argc==3) {
				//copy(argv[2],".");
			}
			else if(argc==4) {
				test(argv[2],argv[3]);
			}
			else {
				fprintf(stderr, "missing arguments...\n");
			}
		}
		else if(!strcmp(argv[1],"type")) {
			printf("HERE %s\n", argv[2]);
			if(argc==3) {
				testd(argv[2]);
			}
			else {
				fprintf(stderr, "missing arguments...\n");
			}
		}


	}
	CLOSEFS();
	getchar();
	return 0;
}

